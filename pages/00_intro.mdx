import Layout from "@/components/Layout";
import { ExternalLink } from "@/components/Link";

export const meta = {
  chapter: null,
  title: "介绍",
  description: "JavaScript 的基本知识",
};

export default ({ children }) => <Layout meta={meta}>{children}</Layout>;

> 我们认为我们在为了自己的目的而创建系统。我们相信它是按照我们自己的设想而被制作的……但是计算机真的和我们不一样。它只是我们自身很小的一部分的投射：这部分专指逻辑、顺序、规则和清晰。
>
> —— Ellen Ullman, Close to the Machine: Technophilia and its Discontents

![Eloquent JavaScript 的介绍](/img/chapter_picture_00.jpeg)

这本书是关于如何命令计算机的。计算机现在就像螺丝起子一样常见，但它们又有些复杂，让它们做一些我们需要它们做的事并不总是那么容易。

如果你想让计算机做的是常见的、易懂的工作的话，例如显示你的电子邮件或者是当个计算器，那么只需要打开适合的程序就可以实现了。但如果是独特的或开放式的任务的话，很可能没有适合的程序来实现。

这时候就需要进行编程了。*编程*就是规划一个*程序*的结构——也就是一组让计算机知道做什么的精确的指令。因为计算机又蠢又迂腐，所以编程打根本上就是一件乏味、令人有挫败感的事情。

幸运的是，如果你可以接受这个事实，并且觉得让傻机器能搞懂的严苛规则有趣的话，那么编程还是很值得做的事情。人类徒手可能永远完不成的事，计算机可以几秒钟就完成了。所以编程可以让你的计算工具完成它以前不会做的事，并且为抽象思考提供了非常奇妙的练习机会。

大部分编程都是通过编程语言来实现的。一个*编程语言*就是一个人为对其结构进行设计的、指导计算机工作的人工语言。有趣的是，最有效的与计算机沟通的方式非常倚重我们与彼此沟通的方式。就像人类语言一样，计算机语言允许词、词组以新的方式组合在一起，从而表达出新的概念。

像是八九十年代的 BASIC 和 DOS 这种基于语言的界面系统，一度是人与计算机交互的主要方式。它们大部分已经被视觉界面所取代了，视觉界面更容易学习，但自由度也变少了。计算机语言一直都存在，只要你知道在哪里能找到它们。有一个计算机语言，JavaScript，所有的现代浏览器中都预置了它，也就是说基本上所有的设备都可以使用它。

本书致力于让你可以足够地熟悉 JavaScript，并能用它来做很多有用、有趣的事情。

## 关于编程

在解释 JavaScript 之外，我还会介绍基本的编程原则。事实上，编程挺难的。虽然基本的规则简单且清晰，但在这些规则基础之上创建的程序需要足够地复杂，才能引入它自身的规则和复杂性。某种意义上说，你在创建自己的迷宫，而你可能会迷失其中。

阅读这本书有时会特别地让人有挫败感。如果你是编程新手，书中有更多的材料要你去学习。大部分这些材料需要你自己额外地花心思把它们*组合到一起*去理解。

需要花多少心思由你自己来决定。当你对理解这本书感到有困难的时候，不要轻易地下结论、怀疑自己的能力。你的能力没有问题，你只是需要坚持下去。休息一下，重新阅读这些材料，确保自己读懂了其中的程序案例和练习。学习是需要努力投入的，而所有你学到的东西都会让你后面的学习变得容易一些。

> 当行为无法获利，那么就收集信息；当信息也无法获利，那么就去睡觉吧。
>
> ——出自厄休拉·勒古恩的《黑暗的左手》

一个程序可以代表很多内容。它是程序员敲出的一段文本，是强制计算机去执行的指令，是存储在内存中的数据，同时它也控制着该内存上执行着的动作。想要把程序和我们熟悉的事物做对比往往是不够的。一个非常表面化的类比是，程序就是机器——涉及很多不同的部件，而为了让机器能够以一个整体来运行，我们要考虑如何组合、利用这些部件。

一台计算机是执行这些无形机器的有形宿主。计算机自己只能做简单直接的事情，它们之所以有用是因为它们做事的速度极快。而程序可以聪明地把数量巨大的简单动作组合在一起从而完成非常复杂的工作。

程序是思想的组合。实现它不用花钱，它也没有重量，在我们的双手敲打之下它就很容易地成长壮大了。

但如果不小心的话，程序的大小和复杂性可能会变得无法控制，让它的作者都变得困惑无措。保证程序的可控是编程的主要问题。当程序可以工作时，它很美好。编程的艺术就是控制复杂性的技能。伟大的程序都是克制的——简化自己的复杂性。

有些程序员认为最好的管理这种复杂性的方式是，在他们的程序中只使用一小组易懂的技术。他们以严格的（「最实用的」）规则指定程序的形式并小心地待在自己的小小舒适区中。

这不止无趣，而且还没有效率。新的问题总是需要新的解决方案。编程这一领域是非常年轻的，并还在快速地发展，而且它还有足够的多样性来探索更多不同的方式。在程序设计中会产生很多错误，而你应该要去犯错误，这样你才能理解它们。判断什么是好程序的能力是在实践中积累出来的，而不是靠学习一系列的规则。

## 为什么语言重要

在计算出现之初，并没有编程语言。程序是这个样子的：

```
00110001 00000000 00000000
00110001 00000001 00000001
00110011 00000001 00000010
01010001 00001011 00000010
00100010 00000010 00001000
01000011 00000001 00000000
01000001 00000001 00000001
00010000 00000010 00000000
01100010 00000000 00000000
```

上面这段程序是把数字 1 到 10 加在一起并打印出结果：`1 + 2 + ... + 10 = 55`。它可以在简单的假想型机器上运行。要对早期的计算机进行编程，就需要设置可以转换到正确位置的大型数组，或在一条条硬纸卡上打孔并把它们投入到计算机里。你可以想象这个流程有多么的乏味和容易出错。复杂到难以置信。

当然，手工输入这些奇妙的小片段（这些 1 或 0）可以给程序员们一种身为伟大的巫师一般的深邃感。就工作成就感而言，这也是值得的。

前面的程序中每一行包含一条指令，用中文表达就是这样的：

1. 把数字 0 存储在内存 0 的位置。
2. 把数字 1 储存在内存 1 的位置。
3. 将内存 1 位置的值储存到内存 2 位置上。
4. 从内存 2 位置上的值中提取出数字 11。
5. 如果内存 2 位置上的值是数字 0，继续执行指令 9。
6. 把内存 1 位置上的值加到内存 0 位置上。
7. 把数字 1 加到内存 1 位置的值上。
8. 继续执行指令 3。
9. 输出内存 1 位置的值。

虽然和前面的 01 片段对比已经好读多了，但还是非常晦涩。使用名称代替指令数和内存数会好一些：

```
Set "total" to 0.
Set "count" to 1.
[loop]
Set "compare" to "count"
Subtract 11 from "compare"
If "compare" is zero, continue at [end].
Add "count" to "total".
Add 1 to "count".
Continue at [loop].
[end]
Output "total"
```

你看到此时程序是如何工作的了吗？前两行给出了两个内存位置的初始值：`total` 被用来表示计算的结果，`count`用来追踪当前的数字。使用`compare`的那几行大概是最怪异的。程序想要看一下`count`是否等于`11`从而决定能否停止运行。因为我们设想中的机器是比较原始的，它只能测试一个数字是否是零，并基于这点做出决定。所以它使用了标记内存位置的`compare`来计算`count - 11`的值，并基于那个值做一个决定。接下来的两行把`count`的值加到了结果中，并在每次程序决定`count`还不是`11`的时候为`count`加`1`。

下面是相同的程序用 JavaScript 的写法：

```js
let total = 0,
  count = 1;
while (count <= 10) {
  total += count;
  count += 1;
}
console.log(total);
// → 55
```

<ExternalLink href="https://eloquentjavascript.net/00_intro.html#p_OW1EmW8ax2" />

这版给了我们更多的赶紧。最重要的是，没有必要再规定程序如何前后跳了，`while`指令就能很好地实现需求。只要满足条件，代码块（大括号内部的内容）就会继续执行。这个条件就是`count <= 10`，也就是「count 小于等于 10」。我们无须再创建一个临时的值，用它和 0 作比较了。那实在太无趣又琐碎了。编程语言的能力之一就是它们能棒我们处理无趣的细节。

在上面这段程序的末尾，当`while`指令结束后，`console.log`这一操作指令就会写出结果。

最后，如果碰巧我们还有更方便的名为`range`和`sum`的操作指令，这两个操作分别是生成一个范围内的一串数字，并计算它们的总和，那么程序就会写成这样：

```js
console.log(sum(range(1, 10)));
// → 55
```

<ExternalLink href="https://eloquentjavascript.net/00_intro.html#p_wn1/ZRqPgW" />

这个故事的寓意是，同样的程序既有长的写法，也有短的写法，即可以写得易于阅读，又可以写得毫无可读性。这个程序的第一版就极其晦涩，而最后一版就是在说人话了：`log`（打印）出从 1 到 10 这一`range`（范围内）的数字的`sum`（总和）。（我们将在[后面的章节](/04_data)中了解如何定义像`sum`和`range`这样的操作指令。）

好的编程语言能让程序员在较高的层次上让计算机实现它们要履行的动作。它能帮忙省略细节，提供方便的代码块（就像`while`和`console.log`），也能让你定义自己的代码块（如`sum`和`range`），并让这些代码块很容易地组合运行。

## 什么是 JavaScript？

JavaScript 是在 1995 年引入的，为了给网景浏览器的网页上增加程序用的。之后其他主要的网络浏览器也都支持了这个语言。它让现代网络应用成为可能。现代网络应用就是无需随着用户的每个动作都重新加载一次页面，就能实现交互。JavaScript 也应用于更传统的网站，用以提供多样的互动形式和零活度。

需要注意的是，JavaScript 与名为 Java 的编程语言毫无关系。名字之所以相似只是因为出于市场营销的考量。当 JavaScript 刚推出的时候，Java 占居了巨大的市场且非常受欢迎。有人认为借势是个好方法，但现在这个名字就困在这儿了。

当网景以外的浏览器开始支持 JavaScript 之后，一份标准文档被撰写出来，用以描述 JavaScript 语言应该要如何工作，这样那些所有声称可以支持 JavaScript 的小程序们就能真正地使用相同的语言了。这被称为 ECMAScript 标准，由 Ecma 国际组织制定。实际应用中，ECMAScript 与 JavaScript 是相同的意思，它们都是同一种语言。

有人会说 JavaScript 有很多不好的地方，而其中大部分都是事实。我第一次被要求用 JavaScript 语言写个什么东西的时候，我一下子就鄙视它了。它把我写的任何东西都编译成了与我意图完全不同的东西。事实上因为我不知道自己要怎么使用 JavaScript，所以花了很多努力在上面。但根本的问题在于：JavaScript 的自由度太夸张了。这个设计的初衷是为了让初学者用 JavaScript 进行编程变得容易。事实上这却让找出程序中有问题的地方变得困难，因为它的整个系统不会自动帮你指出来。

但是这种零活度也有它自己的优势。它为在更保守的语言中无法实现的技术提供了空间，在后面就会看到（例如[第十章](/10_modules)），因此它的优势战胜了不足。在正确地学习并使用了这个语言一段时间之后，我真的*喜欢上*JavaScript 了。

JavaScript 有好几种版本。在 JavaScript 迅速发展壮大的时期，被广泛支持的是 ECMAScript 3，那大约是在 2000 年到 2010 年间。那段时间中，雄心勃勃的第 4 版正在被研发，按照计划第 4 版中会有一些针对此语言根本性的改进和扩展。以如此激进的方式改变一种被广泛使用的语言是非常困难的，于是在 2008 年第 4 版被废止了。接下来出现了没那么有雄心的第 5 版，这版只做了一些没有争议的改进，在 2009 年推出。之后在 2015 年第 6 版面世了，这版是次大型的更新，其中包括一些第 4 版中的改变计划。自那儿之后，JavaScript 每年都会有些小的更新。

事实是，这个语言的进化意味着浏览器也要持续跟上它的脚步。如果你使用的是老款的浏览器，它可能不会支持每个功能。语言的设计者都非常小心地处理每个改变，以免让现存的程序崩溃了，所以新的浏览器也可以支持以前的老程序。在这本书中我将使用 2017 年版的 JavaScript。

网络浏览器不是 JavaScript 运行的唯一平台。有些数据库如 MongoDB 和 CouchDB 都使用 JavaScript 作为它们的脚本和查询语言。有些桌面平台和服务器程序——大多数都是 Node.js 项目（这个主题将在[第 20 章](/20_node)讨论），都提供了一个浏览器之外的环境来运行 JavaScript。

## 代码，及怎么使用它

*代码*就是组成程序的文本。这本书的大多数章节都会包含很多代码。我相信阅读和编写代码对学习编程来说都是必要的。尝试不要只是浏览那些代码案例，而是有意地阅读它们，弄懂它们。这在刚开始可能会很慢而且充满困惑，但我向你保证很快你就能上手了。对于练习也是这样，不要在真正地写出来一个解决方案之前，就以为你自己弄懂它了。

我建议你在一个真正的 JavaScript 解释器中尝试你对练习的解决方案。那样你才能很快地得到反馈，知道自己是否应该那么处理。并且我希望你能被实践所吸引，然后尝试更多的内容。

当你在浏览器中阅读本书时，可以通过点击来编辑（和运行）所有的代码案例。（此中文译版不支持此功能，我会在每段代码后面附上原英文网址。）

如果你想在本网站（只原英文网址）之外运行本书中的代码，那么就需要小心了，因为很多代码案例是独立的可以在任何 JavaScript 环境中运行，而后面章节的一些代码则需要特定的运行环境（浏览器或 Node.js），且只能在那儿运行。另外，有些章节中的是大型代码，那些片段都互相关联，或者需要外部的文件支持。网站上的这个[sandbox](https://eloquentjavascript.net/code/)提供了一个 Zip 文件的下载链接，此文件中包含了给定章节中的代码运行时需要的文件。

## 本书概览

本书大致可以分为三个部分。前十二章讨论了 JavaScript 语言；之后的七章是关于网络浏览器和如何用 JavaScript 对其进行编程；最后两章是关于 Node.js 的，那是另一个 JavaScript 的运行环境。

贯穿本书一共有五个*项目章节*，这些章节介绍了大型的程序案例，让你了解正式的编程是什么样子的。按出现的顺序分别是[快递机器人](/07_robot)、一个[编程语言](/12_language)、一个[平台游戏](/16_game)、一个[像素画程序](/19_paint)和一个[动态交互网站](/21_skillsharing)。

本书中关于语言部分的前四章介绍了 JavaScript 语言的基本结构，包括：[控制结构](02_program_structure)（例如你在本篇中看到的`while`关键词），[函数](03_functions)（编写你自己功能组件）和[数据结构](04_data)。这之后，你就能编写基本的程序了。接下来第五章和第六章讲一些技巧，这些技巧是使用函数和对象编写更为抽象的代码，并让其复杂性保持可控。

在[第一个项目章节](/07_robot)之后，本书中关于语言的部分会继续介绍[错误处理和 bug 修正](/08_error)、[正则表达式](/09_regexp)（一个非常重要的处理文本的工具）、[模块化](/10_modules)（另一个针对复杂性的保护机制）和[异步编程](/11_async)（如何处理那些要花时间的事件）。[第二个项目章节](/12_language)将对整个第一部分进行总括。

从[第 13 章](/13_browser)到[第 19 章](/19_paint)是第二部分，这部分介绍了运行 JavaScript 的工具——浏览器。你将学到在屏幕上显示一些内容（[第 14 章](/14_dom)和[第 17 章](/17_canvas)），回应用户输入的内容（[第 15 章](/15_event)）及通过网络进行通讯（[第 18 章](18_http)）。这部分中会有两个项目案例。

之后，[第 20 章](/20_node)会介绍 Node.js，[第 21 章](/21_skillsharing)是使用 Node.js 制作一个小型的网站。

## 排版规则

本书中（本翻译中），使用英文呈现的大部分都是程序内容，有些是独立的片段，有些会与附近的程序互相关联。程序就是下面这样的（你已经看到过一些了）：

```js
// factorial：阶乘
function factorial(n) {
  if (n == 0) {
    return 1;
  } else {
    return factorial(n - 1) * n;
  }
}
```

<ExternalLink href="https://eloquentjavascript.net/00_intro.html#p_tcuoG/QVih" />

有时为了展示一段程序预期会产生的结果，这个结果会写在程序的下面，以两个反斜杠和一个箭头作为标记：

```js
console.log(factorial(8));
// → 40320
```

<ExternalLink href="https://eloquentjavascript.net/00_intro.html#p_+8owyhMhJN" />

## 翻译规则

向大家说明一下，我不会逐字按照英文的书写内容来翻译本书，因为根据我自己的学习经验，「翻译腔」会给理解编程增加难度，所以我会按照自己对 JavaScript 编程的理解将翻译内容表达得更口语一些。

我也会改变一些词汇的翻译说法，更便于理解，免得大家被难懂的术语打消了积极性。例如书中出现的英文「building block」，常见的译法是「构件」，使用情境如「函数就是你自己编写的构件」。在英文中「building block」有着很直观的意思，就是「制作、搭建什么东西时使用的一块块、一个个的组成部分、组成零件」，所以我倾向于把「building block」翻译成「功能组件」，因为「函数」是实现某种功能和目的的。

我会尽量整理出这些我做了差异化翻译的词汇，以便大家在阅读其他资料时不要出现误解。

另外，因为代码案例都是英文的，那些英文词汇本身就可以解释那段代码的用意，例如上面的`factorial`函数，「阶乘」就已经说明这个函数是干嘛用的了。所以我也会在代码块中把其中涉及的英文单词一并翻译了。

也希望大家可以熟悉这些英文单词，从而形成「把名称取得有意义」这一编程概念。例如我们可以把上面那个函数命名为`jieCheng`，而不要随便取个名字`abc`之类的。「有意义地命名」是个很好的编程习惯。

预祝大家学习顺利！过程中有任何疑问和建议，欢迎在[「我们来开发」论坛](https://womenlai.dev)留言给我，感谢！
