import Layout from "@/components/Layout";
import Note from "@/components/Note";

<Layout
  meta={{
    chapter: "第三章",
    title: "函数",
    description: "解释JavaScript的函数、作用域和闭包",
  }}
>

> 人们认为计算机科学是天才的艺术，而现实正是相反。它是人们在其他人作品的基础上做出来的，就像一块块小砖砌起的墙一样。
>
> ——Donald Knuth

![蕨类树叶图](https://eloquentjavascript.net/img/chapter_picture_3.jpg)

函数是 JavaScript 程序的面包和黄油。把一段程序打包放进一个值中，这个概念有很多用处。它向我们提供了一个途径用以安排大程序的结构，减少重复性，将子程序与名称进行关联，以及让子程序彼此独立。

对程序最突出的运用就是定义新的词汇。在文章中发明新词可不是好事，但在编程中，这确是必要的。

典型的成年英语使用者的词汇量是 20000 个单词。有些编程语言就内建了 20000 个命令。而编程词汇则定义得更准确，不像人类语言那样具有灵活性。因此，我们需要经常引入新的概念来避免太多的自我重复。

## 定义一个函数

一个函数的定义是一个常规的绑定，其绑定的值是一个函数。如下面的例子，代码定义了一个`square`（平方）函数，根据给定的值来求它的平方：

```javascript
const square = function (x) {
  return x * x;
};

console.log(square(12));
// → 144
```

一个函数是由以关键词`function`开始的表达式创建的。函数拥有一组形式参数（本例中只有一个`x`）和一个主体，主体包含当函数被调用时会执行的语句。创建函数主体的方式就是永远要把内容包裹在大括号中，即使只有一条语句。

<Note>
  <p>这章中涉及的是「形式参数」（parameter），上一章中提到的是「实际参数」（argument）。这两者的差别是：</p>

  <ul>
    <li>形式参数是在定义函数时写在括号里面的一组「名称」，像这个例子中我们给形式参数起的名字是<code>x</code>，也可以取名为<code>number</code>或其他，那么<code>number</code>或其他就是这个例子中的形式参数了。</li>
    <li>实际参数是实际给到函数的值，例如上例代码中的`12`就是实际参数。</li>
  </ul>
</Note>

一个函数可以有很多形式参数，也可以完全没有形式参数。下面的例子中，函数`makeNoise`（制造噪音）完全没有形式参数，而函数`power`（冪，次方）则有两个：

```javascript
const makeNoise = function () {
  console.log("Pling!");
};

makeNoise();
// → Pling!

// base：基本值，exponent：指数，result：结果，count：次数
const power = function (base, exponent) {
  let result = 1;
  for (let count = 0; count <Layout exponent; count++) {
    result *= base;
  }
  return result;
};

console.log(power(2, 10));
// → 1024
```

有些函数可以产生值，例如前面的`power`和`square`函数；有些则不会，例如`makeNoise`它的唯一的结果只是产生了一个副作用。`return`（返回）语句定义了函数所返回的值。当执行过程中遇到了这个`return`语句，执行就会立即从函数中跳出并把返回的值传递给调用它的代码。当`return`关键词后面没有表达式时，那么这个函数将返回`undefined`。如果函数根本没有`return`的话，例如`makeNoise`，那么它返回的也是`undefined`。

函数中的形式参数的执行表现就和常规的绑定一样，不过它们的初始值是在函数被调用时给定的，而不是函数这段代码本身决定的。

<Note>
  以上这段话的意思就是，再以<code>square</code>那段代码为例，形式参数
  <code>x</code>
  就如常规绑定一样会获得一个值。这个值是在函数被调用时获得的，即在执行
  <code>square(12)</code>时给了它<code>12</code>这个值，而不是在定义<code>
    square
  </code>
  函数时从函数内部给到它的。
</Note>

## 绑定和作用域（Bindings & Scopes）

每一个绑定都有一个*作用域*，即在程序中的这个部分，绑定都是可见的。对在任何函数或代码块外面的绑定来说，全部代码都是它们的作用域，也就是你可以在任何地方使用这些绑定。它们被称为「全局的（global）」。

但是那些为函数的参数所创建的绑定，或者在函数内部进行的语句，则只能在该函数内使用，因此它们被称为「局部的（local）」。每次函数被调用时，就会为这些绑定创建新的实例。这为不同的函数之间提供了独立性——每个函数都可以在自己的小世界中运行（它的局部环境），在对全局没有任何了解的情况下也能让人理解它的功能。

在*一块代码中*使用`let`和`const`声明的绑定就是属于这块代码局部的，所以当你在一个循环中创建了这样一个语句，那么此循环之前或之后的代码都无法「看见」这个语句。在前 JavaScript 2015 时代，只有函数能创建新的作用域，所以使用`var`关键词创建的那种老式绑定能贯穿、覆盖它所在的整个函数。或者如果它不在函数中，就会覆盖全局。

```js
let x = 10;
if (true) {
  let y = 20;
  var z = 30;
  console.log(x + y + z);
  // → 60
}
// y在此处是不可见的
console.log(x + z);
// → 40;
```

任何作用域都可以「向外」看到它周围的作用域，所以上例中`if`代码块是可以看见`x`的。例外的情况是，当很多绑定都用同一个名称时，代码只能看到最里面的那个。如下例，`halve`（对半分）函数中的代码只能看到*它自己的*`n`，看不到全局的`n`。

```js
const halve = function (n) {
  return n / 2;
};

let n = 10;
console.log(halve(100));
// → 50

console.log(n);
// → 10
```

### 嵌套作用域

JavaScript 不只能区分出全局和局部的绑定。代码块和函数内部可以创建其他的代码块和函数，从而产生多种层次的「局部」。

下面这个关于制作鹰嘴豆酱（hummus）的原料（ingredient）的函数里面还嵌着一个函数：

```js
const hummus = function (factor) {
  // amount：数量；unit：单位；name：原料名称
  const ingredient = function (amount, unit, name) {
    let ingredientAmount = amount * factor;
    if (ingredientAmount > 1) {
      unit += "s";
    }
    console.log(`${ingredientAmount} ${unit} ${name}`);
  };

  ingredient(1, "can", "chickpeas");
  ingredient(0.25, "cup", "tahini");
  ingredient(0.25, "cup", "lemon juice");
  ingredient(1, "clove", "garlic");
  ingredient(1, "tablespoon", "olive oil");
  ingredient(1, "teaspoon", "cumin");
};
```

`ingredient`函数中的代码可以看到外层函数的`factor`绑定。但是其局部的绑定，如`unit`和`ingredientAmount`对外层函数来说就是不可见的。

一块代码中绑定的可见度是由这块代码在程序文本中的位置决定的。每个局部作用域都能看到它外层的所有局部作用域，且所有的作用域都能看到全局作用域。这种处理绑定可见度的方法叫做*词法作用域*（lexical scoping）。

<Note>
  也就是说 JavaScript
  怎么限定代码的作用域是基于程序员怎么「写」这些代码的，写的时候如何嵌套的，定义绑定时用的是
  <code>var</code>、<code>let</code>还是<code>const</code>
  。这都是怎么「写」代码，所以称为「词法」作用域。
</Note>

### 函数作为值

一个函数绑定通常就是简单地给一段特定的程序取个名字。这样一个绑定只被定义一次且永远不变。这很容易对函数和其名称产生困惑。

但是这两者（名称和函数）是不同的。一个函数形式的值（一个函数就是一个值）可以做所有其他值可以做的事情，可以把它用于任意的表达式，而不仅仅是调用它。也可以将一个函数形式的值存储到一个新的绑定上，或把它当作实际参数传递给一个函数等等。同样的，一个关联了某个函数的绑定（即前面提到的「名称」）仍然仅仅是一个普通的绑定，如果它不是常量的话，也可以被赋予新的值。例如：

```js
// launch：发射；missile：导弹
let launchMissiles = function () {
  // missileSystem：导弹系统
  missileSystem.launch("现在");
};

// safeMode：安全模式
if (safeMode) {
  launchMissiles = function () {
    /* 做些其他的事 */
  };
}
```

在第五章中，我们将讨论把函数形式的值传递给其他函数时可以实现的有趣的情况。

## 声明式标记法

还有一种稍微简短的创建函数绑定的方式。当把`function`这个关键词放在语句的开始时，写法就不一样了：

```js
function square(x) {
  return x * x;
}
```

这就是一个*声明式*函数。语句定义了名为`square`的绑定，并将它指向给定的函数。这种写法稍微简单一些，而且在结尾也不用写英文分号了。

这种定义方式有个微妙的地方。

```js
console.log("未来是：", future());

function future() {
  return "永远都不会有飞行汽车的。";
}
```

上面的代码可以正常执行，即使函数是在它*下面*定义的。**声明式函数**不属于常规的由上到下执行的程序流。它们从概念层面被移动到了它们所在作用域的最上面，以让这个作用域中所有的代码都能使用它们。这有时很有好处，因为它为书写代码提供了自由，让代码的结构更有意义，而不用担心必须要把函数们都写在最前面。

## 箭头函数（Arrow Functions）

还有第三种函数的标记法，它看起来与其他两种非常不同。它不使用关键词`function`，而是使用一个箭头`=>`（由等号和大于号组成，可别把它和「大与等于」弄混了，大于等于是`>=`。）

```js
const power = (base, exponent) => {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
};
```

箭头放在形式参数们的*后面*，然后跟着函数的主体。它表达着这样的意思：「这个输入的内容（形式参数）可以产生这个结果（主体）。」

当只有一个形式参数时，可以省略掉包裹形式参数的括号`()`。如果主体只有一个表达式，而不是大括号中的一块代码时，那个表达式就是函数返回的内容。因此，下面两种定义`square`的方式是相同的：

```js
const square1 = (x) => {
  return x * x;
};
const square2 = (x) => x * x;
```

当箭头函数完全没有形式参数时，它用来写形式参数的位置就是一对空的括号。

```js
// horn：喇叭
const horn = () => {
  console.log("呜！");
};
```

在本语言中既存在箭头函数又存在`function`表达法并没有深层的原因。除了一点我们将在[第六章](/06_object)讨论的小细节之外，它们基本是一样的。箭头函数是在 2015 版中增加的，主要是用于在写函数时可以少写一些字。我们在[第五章](/05_higher_order)中将大量地使用箭头函数。

## 调用堆栈（The Call Stack）

控制流程在函数中流动的方式是有些难懂的。我们来看一下，下面这段程序中有一些函数调用：

```javascript
function greet(who) {
  console.log(who + "，你好！");
}
greet("哈利");
console.log("再见！");
```

这段程序的执行顺序大概是这样的：由于调用了`greet`导致控制流程要跳回到开始的那个函数（第 2 行），这个函数调用了`console.log`，此时`console.log`开始做事，当它做完了之后，控制流又回到了第 2 行，即这个函数里。（`console.log`做事的时候是在`console.log`里，不是在这个函数里。）此时我们已经运行完`greet`函数了，到底了，就要返回到调用它的位置了，也就是第 4 行。后面的一行再次调用`console.log`，它再返回之后，我们就到这段程序的底部了。

图示这个流程是这样的：

```
not in function
   in greet
        in console.log
   in greet
not in function
   in console.log
not in function
```

当一个函数返回了值之后，它必须要跳回到调用它的地方，因此计算机必须要记住那个调用发生时的情境。像是函数里面的`console.log`执行完之后就要回到`greet`函数里面。另一个`console.log`执行完之后就回到了程序的底部。

计算机中用来存储这些情境的地方就是*回调堆栈*。每次一个函数被调用时，当前的情境会被存储在堆栈的最上面。当一个函数返回了值之后，最上面的那个情境就会从堆栈中移除，这个情境会被用来继续执行后面的内容。

存储堆栈需要占用计算机的内存。当堆栈太大的时候，计算机会停止运行并给出「没有堆栈空间了」或者「太多次递归了」这样的信息。下面的代码就描绘了这种情况，它向计算机提出了一个困难的问题，导致了在两个函数中无限地循环往复。或者说它*应该是*无限的，只要计算机拥有无限的堆栈空间。然后我们就没有空间可用了，或者「把栈给撑爆了」。

```javascript
// egg：蛋；chicken：鸡
function chicken() {
  return egg();
}
function egg() {
  return chicken();
}
console.log("是先有" + chicken() + "的。");
// → ??
```

## 实际参数是可选的

下面的代码是可以顺利执行的：

```javascript
function square(x) {
  return x * x;
}
console.log(square(4, true, "hedgehog"));
// -> 16
```

我们只给`square`定义了一个形式参数，但是当我们用三个实际参数调用它时，本语言也不会抱怨。它会忽略额外的实际参数，并且用第一个来计算平方。

JavaScript 对于传递给它的实际参数的数量是非常宽容的。如果给的太多，额外的就会被忽略；如果给的太少，那个没被对应上的形式参数会被赋予`undefined`这个值。

这种情况的坏处是，你可以不小心给函数传递了错误数量的实际参数，然而没有人会告诉你你错了。

这个情况的好处是，可以用不同数量的实际参数来调用函数。例如`minus`函数试图模仿减号`-`对一个实际参数和两个实际参数不同的作用：

```javascript
function minus(a, b) {
  if (b === undefined) return -a;
  else return a - b;
}

console.log(minus(10));
// -> -10
console.log(minus(10, 5));
// -> 5
```

如果你在形式参数后面写上一个等于号`=`，并在其后再写一个表达式，那么当没有给它实际参数时，那个表达式的值就会是这个形式参数的值。

例如，这版`power`函数中第二个实际参数是可选的。你无需为它提供或传递给它`undefined`这个值，它默认就是`2`，使函数实现计算平方的效果。

```javascript
function power(base, exponent = 2) {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
}

console.log(power(4));
// → 16
console.log(power(2, 6));
// → 64
```

在下一章中我们会看到如何让函数的主体可以接受所有传递给它的实际参数。因为这让函数可以接受任意数量的实际参数成为可能，所以很有用处。例如`console.log`就是这样，它能输出给到它的所有值：

```javascript
console.log("C", "O", 2);
// -> C O 2
```

</Layout>
