import Layout from "@/components/Layout";

export const meta = {
  chapter: "第一章",
  title: "值、类型和运算符",
  description: "JavaScript 的值、类型和运算符",
};

export default ({ children }) => <Layout meta={meta}>{children}</Layout>;

> 在机器的表面下，程序在移动。毫不费力地，它们扩张、收缩。在伟大的和谐中，电子扩散着、重组着。屏幕上的形状就如水面的涟漪。本质则在下面隐身着。
>
> —— Yuan-Ma 大师，《编程之书（The Book of Programming）》

![值、类型和操作符](/img/chapter_picture_1.jpeg)

在计算机世界的内部只有数据。你可以读数据，修改数据，创建新的数据，但那些不是数据的东西却不能被提及。所有这些数据都以长序列的比特形式存储，因此从本质上来说它们是相似的。

*比特*是二进制的，通常由 0 和 1 指代。在计算机内部，它们的形式就像是或高或地的电荷，或强或弱的信号，CD 光盘表面闪亮或黯淡的斑点。任何单独的信息都可以被缩减到 1 和 0 的组合，以比特的形式呈现。

> 比特（英语：bit）是二进制中的一位，是信息的最小单位。Bit 是 binary digit（二进制数位）的混成词。（[引述自维基百科](https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83)）

例如，我们可以用比特来表达数字 13。它的工作方式和十进制一样，但十进制是 10 个不同的数字，而比特只有 2 个，且每个数字的权重从右到左增加 2 倍。以下是组成数字 13 的比特，权重标记在数字的下面：

```
   0   0   0   0   1   1   0   1
 128  64  32  16   8   4   2   1
```

这就是二进制数字`00001101`，其中非零数字代表着 8、4 和 1，它们加在一起是 13。

## 值

请想象一个比特的海洋。一台典型的现代计算机它的易失性数据存储器（工作内存）中有超过 300 亿的比特，非易失性存储器（硬盘或等效存储设备）的容量往往要高出几个数量级。

为了能在如此海量的比特中工作且不迷失，我们必须要把它们分成一堆儿一堆儿的来代表信息片段。在 JavaScript 环境中，那「一堆儿一堆儿」被成为*值*。即使所有的值都是由比特组成的，它们的身份也不相同。每个值都有一个「类型」来决定着它的身份。有些值是数字，有些是文本，有些则是函数，等等。

要创建一个值，只需仅仅给它取个名字。这是很方便的。你不用为你的值收集建造材料或花钱，你只需要叫它一声，然后唰地一下它就出现了。当然，它们不是凭空被创造的。每个值都要被储存在某个地方，而如果你要在同时大量地使用它们，内存可能会不够用的。幸运的是，这个问题只在同时使用它们的时候才会出现。只要你不用哪个值了，它立刻就会消解，被它的比特留给下一代值们循环使用。

这一章将介绍 JavaScript 程序的原子类元素，那就是简单的值「类型」和作用于这些值的「运算符」。

## 数字

*数字*类型的值毫无意外地就是数字。在 JavaScript 中，它们是写成这样的：

```
13
```

在程序中使用它，就会导致在计算机内出中生成出代表数字 13 的比特模式。

JavaScript 使用固定数量的比特数位（64 位）来存储单一的数值。64 位可以形成的模式只有这么多，这就意味着用来表示不同数字的数量是有限的。使用*N*个十进制数字，可以表示 10<sup>N</sup>个数字。相似地，相似的 64 个二进制数字，你可以用来代表 2<sup>64</sup>个不同的数字，大约为 18 亿位数（一个 18 位数后面跟着 18 个零）。这可不少了。

以前计算机的内存更小，人们试图用 8 位或 16 位的比特来表示数字。这么小的数字很容易就无意地*溢出*了，最终的数字无法用给定的比特来表示。今天，即使可以放进口袋的计算机都有大量的内容，所以你可以放心地使用 64 位的比特堆儿，只有在处理天文数字时才需要担心溢出问题。

但是，不是所有的小于 18 亿位数的数字都能适用于 JavaScript 数字。那些储存负数的比特，还要留出一位来表示负号。更大的问题是非整数也必须表示出来。为此，有些比特被出来存储小数点的位置，所以实际用来储存完整数字的范围在 9 亿位数，依旧很巨大。

有小数的数字使用点来表示：

```
9.81
```

对于非常大或非常小的数字，还需要用到科学技术法 _e_（exponent，_指数_），e 后面是该数字的指数：

```
2.998e8
```

这个数字就是 2.998 × 10<sup>8</sup> = 299,800,000。

计算小于 90 万亿的整数（integer）可以总是保证其准确性。不幸的是，计算带小数的数字往往就不行了，就像 π（Pi）无法用有限的十进制数字精确表示一样。当只有 64 位来存储它们时，很多数字都会失去一些精确度。这很令人遗憾，不过也仅在很特定的情况下才会产生实际的问题。重要的是要意识到这点，并将带小数的数字视为近似值，而不是精确值。

### 算术

使用数字主要要做的事情就是算术。算术运算符像是加号或乘号就是把让两个数字产生一个新的数字。下面是它们在 JavaScript 中的样子：

```
100 + 4 * 11
```

`+`和`*`这两个符号称为*运算符*。第一个代表相加，第二个代表相乘。在两个值中间放置一个运算符，就会让这两个值产生一个新的值。

但上面的例子到底是「4 和 100 先相加，结果再乘以 11」呢？还是先做乘法再做加法呢？你可能已经猜到了，是先做乘法。就像在数学中，只要加上括号就可以改变运算顺序：

```
(100 + 4) * 11
```

减法则有`-`运算符，除法有`/`运算符。

当存在很多运算符且没有括号的时候，它的运算顺序由运算符的优先级来决定。像上例中相乘优先于相加。`/`运算符与`*`运算符的优先级相同，同样`+`与`-`的优先级相同。当多个优先级相同的运算符一起出现时，如`1 - 2 + 1`，它的运算顺序就是从左向右的：`(1 - 2) + 1`。

你不用担心这些优先级的规则，如果不确定，给它们加上括号就好了。

还有一个算术符号你可能不会一下就识别出来，它就是`%`。百分号符号是*余数*运算符。`X % Y`计算的是 X 除以 Y 剩下的余数。例如，`314 % 100`结果是`14`，`144 % 12`结果是`0`。余数运算符的优先级与乘法和除法相同。你也会经常看到这个运算符被称为*模数*。

### 特殊数字

在 JavaScript 中还有三个特殊的值被视为数字，但它们的用法却与普通数字不同。

前两个是`Infinity`和`-Infinity`分别代表正的和负的的无限值（无穷大和无穷小）。`Infinity - 1`扔让是`Infinity`，以此类推。但请不要太相信无限运算了。从数学上讲，这不好，而且这很快会引出下一个特殊数字：`NaN`。

`NaN`表示「不是一个数字（not a number）」，即使它*确实*是个数字类型的值。当进行如下计算时就会得到这个结果：例如`0 / 0`（零除以零），或`Infinity - Infinity`，或者其他的产生无意义内容的数字运算。

### 字符串

下一个基本的数据类型是*字符串*。字符串用来表示文本。它们要以*英文引号*包裹：

```
`Down on the sea`; // 反引号
("Lie on the ocean"); // 双引号
("Float on the ocean"); // 单引号
```

你可以使用单引号、双引号或反引号，只要保证开始和结束的引号相同（相对应）就行。

几乎所有的内容都能放在引号中，之后 JavaScript 就会把它视为一个字符串值。但对有些字符的处理也是有困难的。可以想象一下引号里还包含引号，那就有些麻烦了。还有*另起一行*（当使用键盘上的 Enter 键换行的时候），如果不用反引号（`）的话，所有的文本就会被连在一起。

为了解决上述的情况，我们会使用一个标记：`\`。当引号包裹的文本中出现了`\`的时候，就表示它后面的字符有着特殊的意义。这被称作*转义字符*。被反斜杠标记的引号不会被当作字符串的结尾，只会被当作文本的一部分。当反斜杠后面的字符是`n`的时候，这个组合就会被解释为「另起一行」。相似地，当反斜杠与`t`组合在一起时，它们表示的是一个制表符（tab，也代表缩进）。像是下面这个字符串：

```
"这是第一行\n而这是第二行";

```

以上字符串代表的实际意思是这样的：

```
这是第一行;
而这是第二行;
```

当然有时候你需要反斜杠在文本中就是普通的反斜杠，而不是特殊的标记。如果两个反斜杠挨在一起，它们就会合二为一，只有一个会在字符串的结果值中出现。以下就是实现——「表示另起一行的字符是这样的"\n"。」——这句话的写法：

```
"表示另起一行的字符是这样的\"\\n\"。";

```

为了能够存在于计算机中，字符串也会被模型化为一串比特。JavaScript 是基于 Unicode 标准进行这种转化的。这个标准实际上为你可能需要的每个字符都分配了一个数字，这些字符包括希腊文、阿拉伯文、日文和亚美尼亚文等。如果每个字符都有一个数字，那么一个字符序列就可以用来描述一个字符串了。

> 例如汉字「我」的 Unicode 是 U+6211；小写英文字母「a」是 U+0061。大家可以在[这个网站](https://home.unicode.org/)了解更多 Unicode 的知识。

以上就是 JavaScript 的做法。其中复杂的地方是，在 JavaScript 中每个字符串元素都是 16 位来表示，这样最多可以描述 216 个不同的字符。但 Unicode 定义的字符可比这多了去了，就目前来说，大约两倍吧。所以，有些字符像是 emoji 表情符号在 JavaScript 字符串中就会占据两个「字符位置」。我们在[第五章](/05_higher_order)会继续讨论这个话题。

我们无法对字符串进行相乘、相除或相减，但`+`运算符可以用在字符串上。它的功能不是相加，而是*连接*——它能把两个字符串连在一起。下面代码例子的结果就是产生字符串：`"concatenate"`。

```
"con" + "cat" + "e" + "nate";
```

JavaScript 中有一些对字符串进行其他操作的函数（也就是*方法*），我们会在[第四章](04_data#methods)中介绍它们。

用英文单引号或英文双引号表示字符串的效果是一样的，不同的地方在于你的字符串内会使用到哪种引号。例如「他先说了一声"hello"」，因为字符串里面用到了双引号，那么字符串本身就要用单引号来包裹：`'他先说了一声"hello"'`。这样也可以免掉使用转义字符的麻烦。

使用反引号表示字符串通常被称为*模板文字*（template literals），它可以玩出一些花样来。除了可以换行之外，它还可以接受其他的值：

```
`100的一半是${100 / 2}`
```

在模板文字中，当你把内容写在`${}`内时，JavaScript 会计算它的结果，并把结果转换成字符串放在相应的位置上。所以上例的结果是：「100 的一半是 50」。

### 一元运算符

不是所有的运算符都是符号，有些是写成词语的。例如`typeof`运算符，它产生一个字符串值用以说明你给定的那个值的类型。

```js
console.log(typeof 4.5);
// → number
// 上面这个number是一个字符串，它说明了4.5这个值的类型是数字

console.log(typeof "x");
// → string
// 上面这个string是一个字符串，它说明了"x"这个值的类型是字符串
```

我们在代码案例中使用`console.log`来表示我们想要看到代码的执行结果。这在[下一章](/02_program_structure)会更多地涉及。

> console 的意思是「控制台」，log 的意思是「做记录」。`console.log`是让程序「在控制台中打印出括号里面执行结果」，这个命令在 JavaScript 编程中会起到很大的作用，大家可以在后面的章节中慢慢了解它的使用方法。

其他运算符都是对两个值进行运算操作，但`typeof`是对一个值进行操作。对两个值进行操作的被称为*二元*（binary）运算符，对一个值进行操作的是*一元*（unary）运算符。负号运算符既可以被用作二元运算符，也可以被用作一元运算符：

```js
console.log(-(10 - 2));
// → -8
```

## 布尔值

当只有两种可能性的时候，如果有一个值可以用来区分它们，这个值则是非常有用的。像是遇到「是」与「否」、「开」与「关」这种情况。为了实现此目的，JavaScript 中就出现了*布尔*（Boolean）类型。这个类型只有两个值：`true`（真的）和`false`（假的），它们以完整的英文单词的形式存在。

### 比较

这是产生布尔值的一种方式：

```js
console.log(3 > 2);
// → true

console.log(3 < 2);
// → false
```

上面的`>`和`<`就是传统的「大于号」和「小于号」，它们都是二元运算符。这个例子它们的运算结果是布尔值，用以说明它们描述的情况是否是真的。

字符串也可以以相同的方式进行比较：

```js
console.log("Aardvark" < "Zoroaster");
// → true
```

字符串对英语进行比较的方式是基于字典中字母表的顺序来的，排在前面的字母 a 小于排在后面的字母 d，而大写字母永远「小于」小写字母，例如`"Z" < "a"`，且标点符号（如感叹号、破折号等）也有它们的顺序。当比较字符串时，JavaScript 是从左到右基于它们的 Unicode 对它们一一进行比较的。

其他类似的「比较」操作符还有`>=`（大于等于）、`<=`（小于等于）、`==`（等于）和`!=`（不等于）。

```js
console.log("痒痒" != "抓痒");
// → true

console.log("橘子" == "苹果");
// → false
```

> 说明：因为在 JavaScript 中等号`=`是用来表示「赋值」的，即——把等号右边的值赋予等号左边的这个名字。所以当表示等于的时候使用`==`或`===`，具体的使用方法后面也会介绍到。

在 JavaScript 中，只有一个*值自己与自己不相等*，那就是`NaN`（not a number，「不是数字」）。

```js
console.log(NaN == NaN);
// → false
```

`NaN`是用来表示无意义的运算结果的，因此，它不可能与*其他的*无意义的运算结果相同。

### 逻辑运算符
